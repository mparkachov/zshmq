#!/usr/bin/env sh
ZSHMQ_EMBEDDED=1
ZSHMQ_VERSION=0.1.2

# shellcheck shell=sh disable=SC2016,SC2317
# [getoptions] License: Creative Commons Zero v1.0 Universal
getoptions() {
	_error="" _on=1 _no="" _export="" _plus="" _mode="" _alt="" _rest="" _def=""
	_flags="" _nflags="" _opts="" _help="" _abbr="" _cmds="" _init=@empty IFS=" "
	[ $# -lt 2 ] && set -- "${1:?No parser definition}" -
	[ "$2" = - ] && _def=getoptions_parse

	i="					"
	while eval "_${#i}() { echo \"$i\$@\"; }" && [ "$i" ]; do i=${i#?}; done

	quote() {
		q="$2'" r=""
		while [ "$q" ]; do r="$r${q%%\'*}'\''" && q=${q#*\'}; done
		q="'${r%????}'" && q=${q#\'\'} && q=${q%\'\'}
		eval "$1=\${q:-\"''\"}"
	}
	code() {
		[ "${1#:}" = "$1" ] && c=3 || c=4
		eval "[ ! \${$c:+x} ] || $2 \"\$$c\""
	}
	sw() { sw="$sw${sw:+|}$1"; }
	kv() { eval "${2-}${1%%:*}=\${1#*:}"; }
	loop() { [ $# -gt 1 ] && [ "$2" != -- ]; }

	invoke() { eval '"_$@"'; }
	prehook() { invoke "$@"; }
	for i in setup flag param option disp msg; do
		eval "$i() { prehook $i \"\$@\"; }"
	done

	args() {
		on=$_on no=$_no export=$_export init=$_init _hasarg=$1 && shift
		while loop "$@" && shift; do
			case $1 in
				-?) [ "$_hasarg" ] && _opts="$_opts${1#-}" || _flags="$_flags${1#-}" ;;
				+?) _plus=1 _nflags="$_nflags${1#+}" ;;
				[!-+]*) kv "$1"
			esac
		done
	}
	defvar() {
		case $init in
			@none) : ;;
			@export) code "$1" _0 "export $1" ;;
			@empty) code "$1" _0 "${export:+export }$1=''" ;;
			@unset) code "$1" _0 "unset $1 ||:" "unset OPTARG ||:; ${1#:}" ;;
			*)
				case $init in @*) eval "init=\"=\${${init#@}}\""; esac
				case $init in [!=]*) _0 "$init"; return 0; esac
				quote init "${init#=}"
				code "$1" _0 "${export:+export }$1=$init" "OPTARG=$init; ${1#:}"
		esac
	}
	_setup() {
		[ "${1#-}" ] && _rest=$1
		while loop "$@" && shift; do kv "$1" _; done
	}
	_flag() { args "" "$@"; defvar "$@"; }
	_param() { args 1 "$@"; defvar "$@"; }
	_option() { args 1 "$@"; defvar "$@"; }
	_disp() { args "" "$@"; }
	_msg() { args "" _ "$@"; }

	cmd() { _mode=@ _cmds="$_cmds${_cmds:+|}'$1'"; }
	"$@"
	cmd() { :; }
	_0 "${_rest:?}=''"

	_0 "${_def:-$2}() {"
	_1 'OPTIND=$(($#+1))'
	_1 "while OPTARG= && [ \"\${$_rest}\" != x ] && [ \$# -gt 0 ]; do"
	[ "$_abbr" ] && getoptions_abbr "$@"

	args() {
		sw="" validate="" pattern="" counter="" on=$_on no=$_no export=$_export
		while loop "$@" && shift; do
			case $1 in
				--\{no-\}*) i=${1#--?no-?}; sw "'--$i'|'--no-$i'" ;;
				--with\{out\}-*) i=${1#--*-}; sw "'--with-$i'|'--without-$i'" ;;
				[-+]? | --*) sw "'$1'" ;;
				*) kv "$1"
			esac
		done
		quote on "$on"
		quote no "$no"
	}
	setup() { :; }
	_flag() {
		args "$@"
		[ "$counter" ] && on=1 no=-1 v="\$((\${$1:-0}+\$OPTARG))" || v=""
		_3 "$sw)"
		_4 '[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break'
		_4 "eval '[ \${OPTARG+x} ] &&:' && OPTARG=$on || OPTARG=$no"
		valid "$1" "${v:-\$OPTARG}"
		_4 ";;"
	}
	_param() {
		args "$@"
		_3 "$sw)"
		_4 '[ $# -le 1 ] && set "required" "$1" && break'
		_4 'OPTARG=$2'
		valid "$1" '$OPTARG'
		_4 "shift ;;"
	}
	_option() {
		args "$@"
		_3 "$sw)"
		_4 'set -- "$1" "$@"'
		_4 '[ ${OPTARG+x} ] && {'
		_5 'case $1 in --no-*|--without-*) set "noarg" "${1%%\=*}"; break; esac'
		_5 '[ "${OPTARG:-}" ] && { shift; OPTARG=$2; } ||' "OPTARG=$on"
		_4 "} || OPTARG=$no"
		valid "$1" '$OPTARG'
		_4 "shift ;;"
	}
	valid() {
		set -- "$validate" "$pattern" "$1" "$2"
		[ "$1" ] && _4 "$1 || { set -- ${1%% *}:\$? \"\$1\" $1; break; }"
		[ "$2" ] && {
			_4 "case \$OPTARG in $2) ;;"
			_5 '*) set "pattern:'"$2"'" "$1"; break'
			_4 "esac"
		}
		code "$3" _4 "${export:+export }$3=\"$4\"" "${3#:}"
	}
	_disp() {
		args "$@"
		_3 "$sw)"
		code "$1" _4 "echo \"\${$1}\"" "${1#:}"
		_4 "exit 0 ;;"
	}
	_msg() { :; }

	[ "$_alt" ] && _2 'case $1 in -[!-]?*) set -- "-$@"; esac'
	_2 'case $1 in'
	_wa() { _4 "eval 'set -- $1' \${1+'\"\$@\"'}"; }
	_op() {
		_3 "$1) OPTARG=\$1; shift"
		_wa '"${OPTARG%"${OPTARG#??}"}" '"$2"'"${OPTARG#??}"'
		_4 "${4:-}$3"
	}
	_3 '--?*=*) OPTARG=$1; shift'
	_wa '"${OPTARG%%\=*}" "${OPTARG#*\=}"'
	_4 ";;"
	_3 "--no-*|--without-*) unset OPTARG ;;"
	[ "$_alt" ] || {
		[ "$_opts" ] && _op "-[$_opts]?*" "" ";;"
		[ ! "$_flags" ] || _op "-[$_flags]?*" - "OPTARG= ;;" \
			'case $2 in --*) set -- "$1" unknown "$2" && '"$_rest=x; esac;"
	}
	[ "$_plus" ] && {
		[ "$_nflags" ] && _op "+[$_nflags]?*" + "unset OPTARG ;;"
		_3 "+*) unset OPTARG ;;"
	}
	_2 "esac"
	_2 'case $1 in'
	"$@"
	rest() {
		_4 'while [ $# -gt 0 ]; do'
		_5 "$_rest=\"\${$_rest}" '\"\${$(($OPTIND-$#))}\""'
		_5 "shift"
		_4 "done"
		_4 "break ;;"
	}
	_3 "--)"
	[ "$_mode" = @ ] || _4 "shift"
	rest
	_3 "[-${_plus:++}]?*)" 'set "unknown" "$1"; break ;;'
	_3 "*)"
	case $_mode in
		@)
			_4 "case \$1 in ${_cmds:-*}) ;;"
			_5 '*) set "notcmd" "$1"; break'
			_4 "esac"
			rest ;;
		+) rest ;;
		*) _4 "$_rest=\"\${$_rest}" '\"\${$(($OPTIND-$#))}\""'
	esac
	_2 "esac"
	_2 "shift"
	_1 "done"
	_1 '[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }'
	_1 'case $1 in'
	_2 'unknown) set "Unrecognized option: $2" "$@" ;;'
	_2 'noarg) set "Does not allow an argument: $2" "$@" ;;'
	_2 'required) set "Requires an argument: $2" "$@" ;;'
	_2 'pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;'
	_2 'notcmd) set "Not a command: $2" "$@" ;;'
	_2 '*) set "Validation error ($1): $2" "$@"'
	_1 "esac"
	[ "$_error" ] && _1 "$_error" '"$@" >&2 || exit $?'
	_1 'echo "$1" >&2'
	_1 "exit 1"
	_0 "}"

	[ "$_help" ] && eval "shift 2; getoptions_help $1 $_help" ${3+'"$@"'}
	[ "$_def" ] && _0 "eval $_def \${1+'\"\$@\"'}; eval set -- \"\${$_rest}\""
	_0 "# Do not execute" # exit 1
}

# shellcheck shell=sh disable=SC2016,SC2317
# [getoptions_abbr] License: Creative Commons Zero v1.0 Universal
getoptions_abbr() {
	abbr() {
		_3 "case '$1' in"
		_4 '"$1") OPTARG=; break ;;'
		_4 '$1*) OPTARG="$OPTARG '"$1"'"'
		_3 "esac"
	}
	args() {
		abbr=1
		shift
		[ $# -gt 0 ] || return 0
		for i in "$@"; do
			case $i in
				--) break ;;
				[!-+]*) eval "${i%%:*}=\${i#*:}"
			esac
		done
		[ "$abbr" ] || return 0

		for i in "$@"; do
			case $i in
				--) break ;;
				--\{no-\}*) abbr "--${i#--\{no-\}}"; abbr "--no-${i#--\{no-\}}" ;;
				--*) abbr "$i"
			esac
		done
	}
	setup() { :; }
	for i in flag param option disp; do
		eval "_$i()" '{ args "$@"; }'
	done
	msg() { :; }
	_2 'set -- "${1%%\=*}" "${1#*\=}" "$@"'
	[ "$_alt" ] && _2 'case $1 in -[!-]?*) set -- "-$@"; esac'
	_2 'while [ ${#1} -gt 2 ]; do'
	_3 'case $1 in (*[!a-zA-Z0-9_-]*) break; esac'
	"$@"
	_3 "break"
	_2 "done"
	_2 'case ${OPTARG# } in'
	_3 "*\ *)"
	_4 'eval "set -- $OPTARG $1 $OPTARG"'
	_4 'OPTIND=$((($#+1)/2)) OPTARG=$1; shift'
	_4 'while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done'
	_4 'set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"'
	[ "$_error" ] && _4 "$_error" '"$@" >&2 || exit $?'
	_4 'echo "$1" >&2'
	_4 "exit 1 ;;"
	_3 "?*)"
	_4 '[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"'
	_4 "shift 3; eval 'set -- \"\${OPTARG# }\"' \${1+'\"\$@\"'}; OPTARG= ;;"
	_3 "*) shift 2"
	_2 "esac"
}

# shellcheck shell=sh disable=SC2016,SC2317
# [getoptions_help] License: Creative Commons Zero v1.0 Universal
getoptions_help() {
	_width="30,12" _plus="" _leading="  "

	pad() { p=$2; while [ ${#p} -lt "$3" ]; do p="$p "; done; eval "$1=\$p"; }
	kv() { eval "${2-}${1%%:*}=\${1#*:}"; }
	sw() { pad sw "$sw${sw:+, }" "$1"; sw="$sw$2"; }

	args() {
		_type=$1 var=${2%% *} sw="" label="" hidden="" && shift 2
		while [ $# -gt 0 ] && i=$1 && shift && [ "$i" != -- ]; do
			case $i in
				--*) sw $((${_plus:+4}+4)) "$i" ;;
				-?) sw 0 "$i" ;;
				+?) [ ! "$_plus" ] || sw 4 "$i" ;;
				*) [ "$_type" = setup ] && kv "$i" _; kv "$i"
			esac
		done
		[ "$hidden" ] && return 0 || len=${_width%,*}

		[ "$label" ] || case $_type in
			setup | msg) label="" len=0 ;;
			flag | disp) label="$sw " ;;
			param) label="$sw $var " ;;
			option) label="${sw}[=$var] "
		esac
		[ "$_type" = cmd ] && label=${label:-$var } len=${_width#*,}
		pad label "${label:+$_leading}$label" "$len"
		[ ${#label} -le "$len" ] && [ $# -gt 0 ] && label="$label$1" && shift
		echo "$label"
		pad label "" "$len"
		[ $# -gt 0 ] || return 0
		for i in "$@"; do echo "$label$i"; done
	}

	for i in setup flag param option disp "msg -" cmd; do
		eval "${i% *}() { args $i \"\$@\"; }"
	done

	echo "$2() {"
	echo "cat<<'GETOPTIONSHERE'"
	"$@"
	echo "GETOPTIONSHERE"
	echo "}"
}

# shellcheck shell=sh

: ${ZSHMQ_COMMAND_REGISTRY:=}

zshmq_register_command() {
  cmd=$1
  case " ${ZSHMQ_COMMAND_REGISTRY} " in
    *" ${cmd} "*)
      :
      ;;
    *)
      if [ -n "${ZSHMQ_COMMAND_REGISTRY}" ]; then
        ZSHMQ_COMMAND_REGISTRY="${ZSHMQ_COMMAND_REGISTRY} ${cmd}"
      else
        ZSHMQ_COMMAND_REGISTRY="${cmd}"
      fi
      ;;
  esac
}

zshmq_command_file() {
  command=$1
  if [ -z "${ZSHMQ_ROOT:-}" ]; then
    return 1
  fi
  file="${ZSHMQ_ROOT}/lib/${command}.sh"
  if [ -f "$file" ]; then
    printf '%s\n' "$file"
    return 0
  fi
  return 1
}

zshmq_command_metadata() {
  command=$1
  key=$2
  file=$(zshmq_command_file "$command") || return 1
  sed -n "s/^[[:space:]]*# *@${key}:[[:space:]]*//p" "$file"
}

zshmq_registered_commands() {
  for cmd in $ZSHMQ_COMMAND_REGISTRY; do
    [ -n "$cmd" ] && printf '%s\n' "$cmd"
  done
}

zshmq_command_summary() {
  command=$1
  summary=$(zshmq_command_metadata "$command" summary | sed -n '1p')
  if [ -n "$summary" ]; then
    printf '%s\n' "$summary"
  else
    printf '%s\n' 'Undocumented command.'
  fi
}

zshmq_parser_defaults() {
  usage_text=${ZSHMQ_PARSER_USAGE:-"zshmq <command>"}
  setup REST help:usage -- "Usage: ${usage_text}" ''
  msg -- 'Options:'
  flag ZSHMQ_HELP -h --help -- 'Display command documentation and exit.'
  flag ZSHMQ_DEBUG -d --debug -- 'Enable DEBUG log level.'
  flag ZSHMQ_TRACE -t --trace -- 'Enable TRACE log level.'
}

zshmq_print_command_help() {
  command=$1
  display_command=$(printf '%s' "$command" | tr '_' ' ')
  usage=$(zshmq_command_metadata "$command" usage | sed -n '1p')
  if [ -z "$usage" ]; then
    usage="zshmq $display_command"
  fi

  printf 'Command: %s\n' "$display_command"
  printf 'Usage: %s\n' "$usage"
  printf '\n'

  description=$(zshmq_command_metadata "$command" description)
  if [ -n "$description" ]; then
    printf '%s\n' "$description"
    printf '\n'
  else
    summary=$(zshmq_command_metadata "$command" summary | sed -n '1p')
    if [ -n "$summary" ]; then
      printf '%s\n\n' "$summary"
    fi
  fi

  options=$(zshmq_command_metadata "$command" option)
  if [ -n "$options" ]; then
    printf 'Options:\n'
    zshmq_command_metadata "$command" option | while IFS= read -r line; do
      printf '  %s\n' "$line"
    done
  fi
}

zshmq_eval_parser() {
  command=$1
  parser_fn=$2
  shift 2
  ZSHMQ_PARSER_USAGE=$(zshmq_command_metadata "$command" usage | sed -n '1p')
  if [ -z "$ZSHMQ_PARSER_USAGE" ]; then
    display_command=$(printf '%s' "$command" | tr '_' ' ')
    ZSHMQ_PARSER_USAGE="zshmq $display_command"
  fi
  unset ZSHMQ_HELP ||:
  unset ZSHMQ_DEBUG ||:
  unset ZSHMQ_TRACE ||:
  # shellcheck disable=SC2039
  eval "$(getoptions $parser_fn zshmq_parse_runner)" || return 1
  zshmq_parse_runner "$@"
  ZSHMQ_REST=$REST
  if [ "${ZSHMQ_TRACE:-0}" = "1" ]; then
    ZSHMQ_LOG_LEVEL=TRACE
  elif [ "${ZSHMQ_DEBUG:-0}" = "1" ]; then
    ZSHMQ_LOG_LEVEL=DEBUG
  fi
  : "${ZSHMQ_LOG_LEVEL:=INFO}"
  export ZSHMQ_LOG_LEVEL
  if [ "${ZSHMQ_HELP:-0}" = "1" ]; then
    zshmq_print_command_help "$command"
    return 2
  fi
  return 0
}

# shellcheck shell=sh

ZSHMQ_LOG_LEVEL=${ZSHMQ_LOG_LEVEL:-INFO}

zshmq_log_level_value() {
  level=$(printf '%s' "$1" | tr '[:lower:]' '[:upper:]')
  case $level in
    TRACE) printf '%s\n' 0 ;;
    DEBUG) printf '%s\n' 10 ;;
    INFO) printf '%s\n' 20 ;;
    WARN) printf '%s\n' 30 ;;
    ERROR) printf '%s\n' 40 ;;
    FATAL) printf '%s\n' 50 ;;
    *) printf '%s\n' 20 ;;
  esac
}

zshmq_log_threshold_value() {
  zshmq_log_level_value "${ZSHMQ_LOG_LEVEL:-INFO}"
}

zshmq_log_should_emit() {
  level_value=$(zshmq_log_level_value "$1")
  threshold=$(zshmq_log_threshold_value)
  [ "$level_value" -ge "$threshold" ]
}

zshmq_log_timestamp() {
  date '+%Y-%m-%d %H:%M:%S'
}

zshmq_log() {
  level=${1:-INFO}
  shift || :
  normalized=$(printf '%s' "$level" | tr '[:lower:]' '[:upper:]')
  zshmq_log_should_emit "$normalized" || return 0

  if [ $# -gt 0 ]; then
    format=$1
    shift || :
    if [ $# -gt 0 ]; then
      message=$(printf "$format" "$@")
    else
      message=$format
    fi
  else
    message=
  fi

  timestamp=$(zshmq_log_timestamp)
  printf '%s [%s] %s\n' "$timestamp" "$normalized" "$message" >&2
}

zshmq_log_trace() {
  zshmq_log TRACE "$@"
}

zshmq_log_debug() {
  zshmq_log DEBUG "$@"
}

zshmq_log_info() {
  zshmq_log INFO "$@"
}

zshmq_log_warn() {
  zshmq_log WARN "$@"
}

zshmq_log_error() {
  zshmq_log ERROR "$@"
}

zshmq_log_fatal() {
  zshmq_log FATAL "$@"
}

# shellcheck shell=sh

#/**
# bus - Manage the routing bus dispatcher.
# @usage: zshmq bus <command> [options]
# @summary: Provision, launch, or tear down the bus that fans messages to multiple topics.
# @description: Provides helpers to bootstrap the special `bus` topic, manage its dispatcher lifecycle, and forward bus messages to topics whose registry regex matches the payload.
# @option: -p, --path PATH    Runtime directory to target (defaults to $ZSHMQ_CTX_ROOT or /tmp/zshmq).
# @option: -f, --foreground   (bus start) Run the dispatcher in the foreground.
# @option: -d, --debug        Enable DEBUG log level.
# @option: -t, --trace        Enable TRACE log level.
# @option: -h, --help         Display command documentation and exit.
#*/

bus_print_usage() {
  printf '%s\n' 'Usage: zshmq bus <command> [options]'
  printf '%s\n' ''
  printf '%s\n' 'Commands:'
  printf '  new      Initialise the bus topic and registry entry\n'
  printf '  destroy  Remove the bus topic and associated assets\n'
  printf '  start    Launch the bus dispatcher (fan-out loop)\n'
  printf '  stop     Terminate the bus dispatcher\n'
}

bus_start_parser_definition() {
  zshmq_parser_defaults
  param BUS_CTX_PATH -p --path -- 'Runtime directory to target'
  flag BUS_FOREGROUND -f --foreground -- 'Run the bus dispatcher in the foreground'
}

bus_stop_parser_definition() {
  zshmq_parser_defaults
  param BUS_CTX_PATH -p --path -- 'Runtime directory to target'
}

bus_resolve_runtime() {
  path=$1

  if [ -z "$path" ]; then
    zshmq_log_error 'bus: target path is empty'
    return 1
  fi

  case $path in
    /|'')
      zshmq_log_error 'bus: refusing to operate on root directory'
      return 1
      ;;
  esac

  if [ ! -d "$path" ]; then
    zshmq_log_error 'bus: runtime directory not found: %s' "$path"
    return 1
  fi

  printf '%s\n' "${path%/}"
}

bus_dispatch_ready() {
  runtime_root=$1
  topic_name=$2

  pid_path=${runtime_root}/${topic_name}.pid
  if [ ! -f "$pid_path" ]; then
    return 1
  fi

  dispatcher_pid=$(tr -d '\r\n' < "$pid_path" 2>/dev/null || :)
  if [ -z "$dispatcher_pid" ] || ! kill -0 "$dispatcher_pid" 2>/dev/null; then
    rm -f "$pid_path"
    return 1
  fi

  return 0
}

bus_publish_to_topic() {
  runtime_root=$1
  route_topic=$2
  message=$3

  topic_fifo_path=${runtime_root}/${route_topic}.fifo

  if [ ! -p "$topic_fifo_path" ]; then
    zshmq_log_debug 'bus dispatcher: fifo missing for topic=%s' "$route_topic"
    return 1
  fi

  if ! bus_dispatch_ready "$runtime_root" "$route_topic"; then
    zshmq_log_debug 'bus dispatcher: dispatcher offline for topic=%s' "$route_topic"
    return 1
  fi

  if ! { printf 'PUB|%s|%s\n' "$route_topic" "$message"; } > "$topic_fifo_path"; then
    zshmq_log_error 'bus dispatcher: failed to forward topic=%s' "$route_topic"
    return 1
  fi

  zshmq_log_trace 'bus dispatcher: forwarded topic=%s message=%s' "$route_topic" "$message"
  return 0
}

bus_route_message() {
  runtime_root=$1
  registry_path=$2
  message=$3

  if [ ! -f "$registry_path" ]; then
    zshmq_log_trace 'bus dispatcher: registry missing (%s)' "$registry_path"
    return 0
  fi

  delivered=0

  while IFS= read -r registry_line || [ -n "$registry_line" ]; do
    case $registry_line in
      ''|\#*)
        continue
        ;;
    esac
    route_topic=$registry_line
    route_regex=
    case $registry_line in
      *'	'*)
        route_topic=${registry_line%%	*}
        route_regex=${registry_line#*	}
        ;;
    esac

    if [ "$route_topic" = "bus" ]; then
      continue
    fi

    if [ -z "$route_regex" ]; then
      continue
    fi

    if printf '%s\n' "$message" | grep -E -- "$route_regex" >/dev/null 2>&1; then
      if bus_publish_to_topic "$runtime_root" "$route_topic" "$message"; then
        delivered=1
      fi
      continue
    fi

    match_status=$?
    if [ "$match_status" -eq 2 ]; then
      zshmq_log_error 'bus dispatcher: invalid regex for topic=%s regex=%s' "$route_topic" "$route_regex"
    fi
  done < "$registry_path"

  if [ "$delivered" -eq 0 ]; then
    zshmq_log_trace 'bus dispatcher: no routes matched message=%s' "$message"
  fi
}

zshmq_bus_loop() {
  bus_fifo_path=$1
  runtime_root=$2
  registry_path=$3

  trap 'exec 3>&-; exit 0' INT TERM HUP
  exec 3<>"$bus_fifo_path"

  while IFS= read -r line <&3; do
    case $line in
      PUB\|*)
        payload=${line#PUB|}
        origin_topic=${payload%%|*}
        message=${payload#*|}
        if [ "$origin_topic" != "bus" ]; then
          zshmq_log_trace 'bus dispatcher: ignoring pub for topic=%s' "$origin_topic"
          continue
        fi
        bus_route_message "$runtime_root" "$registry_path" "$message"
        ;;
      *)
        zshmq_log_trace 'bus dispatcher: ignored frame=%s' "$line"
        ;;
    esac
  done
}

bus_new() {
  runtime_root=$1

  if [ ! -d "$runtime_root" ]; then
    zshmq_log_error 'bus new: runtime directory not found: %s' "$runtime_root"
    return 1
  fi

  topic_new "$runtime_root" bus ''
  zshmq_log_debug 'bus new: prepared bus topic runtime=%s' "$runtime_root"
}

bus_stop_runtime() {
  runtime_root=$1
  pid_path=${runtime_root}/bus.pid

  case $runtime_root in
    /|'')
      zshmq_log_error 'bus stop: refusing to operate on root directory'
      return 1
      ;;
  esac

  if [ ! -f "$pid_path" ]; then
    return 0
  fi

  dispatcher_pid=$(tr -d '\r\n' < "$pid_path" 2>/dev/null || :)
  if [ -z "$dispatcher_pid" ]; then
    rm -f "$pid_path"
    return 0
  fi

  if ! kill -0 "$dispatcher_pid" 2>/dev/null; then
    rm -f "$pid_path"
    return 0
  fi

  kill "$dispatcher_pid" 2>/dev/null || :

  for attempt in 1 2 3 4 5; do
    if ! kill -0 "$dispatcher_pid" 2>/dev/null; then
      break
    fi
    sleep 1
  done

  if kill -0 "$dispatcher_pid" 2>/dev/null; then
    zshmq_log_error 'bus stop: dispatcher (pid=%s) did not terminate' "$dispatcher_pid"
    return 1
  fi

  rm -f "$pid_path"
  zshmq_log_debug 'bus stop: dispatcher stopped (pid=%s)' "$dispatcher_pid"
  return 0
}

bus_destroy() {
  runtime_root=$1

  case $runtime_root in
    /|'')
      zshmq_log_error 'bus destroy: refusing to operate on root directory'
      return 1
      ;;
  esac

  if [ ! -d "$runtime_root" ]; then
    zshmq_log_trace 'bus destroy: runtime missing (%s)' "$runtime_root"
    return 0
  fi

  if ! bus_stop_runtime "$runtime_root"; then
    return 1
  fi

  topic_destroy "$runtime_root" bus ''
  pid_path=${runtime_root}/bus.pid
  rm -f "$pid_path"
  zshmq_log_debug 'bus destroy: removed bus assets runtime=%s' "$runtime_root"
}

bus_start() {
  set -eu

  if ! command -v getoptions >/dev/null 2>&1; then
    if [ -z "${ZSHMQ_ROOT:-}" ]; then
      zshmq_log_error 'bus start: ZSHMQ_ROOT is not set'
      return 1
    fi
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_base.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_abbr.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_help.sh"
  fi

  set +e
  zshmq_eval_parser bus_start bus_start_parser_definition "$@"
  status=$?
  set -e

  case $status in
    0)
      eval "set -- $ZSHMQ_REST"
      ;;
    1)
      return 1
      ;;
    2)
      return 0
      ;;
  esac

  if [ $# -gt 0 ]; then
    zshmq_log_error 'bus start: unexpected argument -- %s' "$1"
    return 1
  fi

  target_path=${BUS_CTX_PATH:-${ZSHMQ_CTX_ROOT:-/tmp/zshmq}}
  runtime_root=$(bus_resolve_runtime "$target_path") || return 1

  bus_fifo_path=${runtime_root}/bus.fifo
  registry_path=$(topic_registry_path "$runtime_root")
  pid_path=${runtime_root}/bus.pid

  if [ ! -p "$bus_fifo_path" ]; then
    zshmq_log_error 'bus start: bus FIFO not found at %s (run bus new first)' "$bus_fifo_path"
    return 1
  fi

  if [ -f "$pid_path" ]; then
    existing_pid=$(tr -d '\r\n' < "$pid_path" 2>/dev/null || :)
    if [ -n "$existing_pid" ] && kill -0 "$existing_pid" 2>/dev/null; then
      zshmq_log_debug 'bus start: dispatcher already running (pid=%s)' "$existing_pid"
      return 1
    fi
    rm -f "$pid_path"
  fi

  if [ "${BUS_FOREGROUND:-0}" = "1" ]; then
    zshmq_bus_loop "$bus_fifo_path" "$runtime_root" "$registry_path" &
    dispatcher_pid=$!
    printf '%s\n' "$dispatcher_pid" > "$pid_path"
    zshmq_log_debug 'Bus dispatcher started (pid=%s)' "$dispatcher_pid"

    bus_start_cleaned=0

    bus_start_cleanup() {
      if [ "${bus_start_cleaned}" -eq 1 ]; then
        return 0
      fi
      bus_start_cleaned=1
      trap - INT TERM HUP EXIT
      if [ -n "${dispatcher_pid:-}" ] && kill -0 "$dispatcher_pid" 2>/dev/null; then
        kill "$dispatcher_pid" 2>/dev/null || :
        wait "$dispatcher_pid" 2>/dev/null || :
      else
        wait "$dispatcher_pid" 2>/dev/null || :
      fi
      rm -f "$pid_path"
    }

    trap 'bus_start_cleanup; exit 130' INT
    trap 'bus_start_cleanup; exit 143' TERM
    trap 'bus_start_cleanup; exit 129' HUP
    trap 'bus_start_cleanup' EXIT

    wait "$dispatcher_pid"
    wait_status=$?
    bus_start_cleanup
    return "$wait_status"
  fi

  zshmq_bus_loop "$bus_fifo_path" "$runtime_root" "$registry_path" &
  dispatcher_pid=$!
  printf '%s\n' "$dispatcher_pid" > "$pid_path"
  zshmq_log_debug 'Bus dispatcher started (pid=%s)' "$dispatcher_pid"
}

bus_stop() {
  set -eu

  if ! command -v getoptions >/dev/null 2>&1; then
    if [ -z "${ZSHMQ_ROOT:-}" ]; then
      zshmq_log_error 'bus stop: ZSHMQ_ROOT is not set'
      return 1
    fi
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_base.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_abbr.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_help.sh"
  fi

  set +e
  zshmq_eval_parser bus_stop bus_stop_parser_definition "$@"
  status=$?
  set -e

  case $status in
    0)
      eval "set -- $ZSHMQ_REST"
      ;;
    1)
      return 1
      ;;
    2)
      return 0
      ;;
  esac

  if [ $# -gt 0 ]; then
    zshmq_log_error 'bus stop: unexpected argument -- %s' "$1"
    return 1
  fi

  target_path=${BUS_CTX_PATH:-${ZSHMQ_CTX_ROOT:-/tmp/zshmq}}

  case $target_path in
    /|'')
      zshmq_log_error 'bus stop: refusing to operate on root directory'
      return 1
      ;;
  esac

  runtime_root=${target_path%/}
  if [ ! -d "$runtime_root" ]; then
    zshmq_log_debug 'bus stop: runtime not found (%s)' "$runtime_root"
    return 0
  fi

  if ! bus_stop_runtime "$runtime_root"; then
    return 1
  fi

  return 0
}

bus() {
  set -eu

  log_level=${ZSHMQ_LOG_LEVEL:-INFO}
  target_path=${ZSHMQ_CTX_ROOT:-/tmp/zshmq}

  while [ $# -gt 0 ]; do
    case $1 in
      -p|--path)
        shift
        if [ $# -eq 0 ]; then
          zshmq_log_error 'bus: --path requires a value'
          return 1
        fi
        target_path=$1
        ;;
      -p=*|--path=*)
        target_path=${1#*=}
        ;;
      -d|--debug)
        log_level=DEBUG
        ;;
      -t|--trace)
        log_level=TRACE
        ;;
      -h|--help|help)
        bus_print_usage
        return 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        zshmq_log_error 'bus: unexpected option -- %s' "$1"
        return 1
        ;;
      *)
        break
        ;;
    esac
    shift || :
  done

  export ZSHMQ_LOG_LEVEL=$log_level

  if [ $# -eq 0 ]; then
    bus_print_usage
    return 1
  fi

  subcommand=$1
  shift

  case $subcommand in
    new)
      runtime_root=$(bus_resolve_runtime "$target_path") || return 1
      if [ $# -gt 0 ]; then
        zshmq_log_error 'bus new: unexpected argument -- %s' "$1"
        return 1
      fi
      bus_new "$runtime_root"
      ;;
    destroy)
      if [ $# -gt 0 ]; then
        zshmq_log_error 'bus destroy: unexpected argument -- %s' "$1"
        return 1
      fi
      case $target_path in
        /|'')
          zshmq_log_error 'bus destroy: refusing to operate on root directory'
          return 1
          ;;
      esac
      runtime_root=${target_path%/}
      bus_destroy "$runtime_root"
      ;;
    start)
      bus_start --path "$target_path" "$@"
      ;;
    stop)
      bus_stop --path "$target_path" "$@"
      ;;
    -h|--help|help)
      bus_print_usage
      return 0
      ;;
    *)
      zshmq_log_error 'bus: unknown command -- %s' "$subcommand"
      bus_print_usage
      return 1
      ;;
  esac
}

if command -v zshmq_register_command >/dev/null 2>&1; then
  zshmq_register_command bus
fi

# shellcheck shell=sh

#/**
# ctx - Manage the runtime directory used by zshmq commands.
# @usage: zshmq ctx <command> [options]
# @summary: Manage the runtime directory (default: /tmp/zshmq).
# @description: Provides subcommands to initialise (`ctx new`) or delete (`ctx destroy`) the runtime directory where FIFOs, state files, and dispatcher metadata live.
# @option: -p, --path PATH    Runtime directory to target (defaults to $ZSHMQ_CTX_ROOT or /tmp/zshmq).
# @option: -d, --debug        Enable DEBUG log level.
# @option: -t, --trace        Enable TRACE log level.
# @option: -h, --help         Display command documentation and exit.
#*/

ctx_print_usage() {
  printf '%s\n' 'Usage: zshmq ctx <command> [options]'
  printf '%s\n' ''
  printf '%s\n' 'Commands:'
  printf '  new      Initialise the runtime directory\n'
  printf '  destroy  Remove the runtime directory (use --force to ignore leftovers)\n'
}

ctx_resolve_target() {
  target=$1

  if [ -z "$target" ]; then
    zshmq_log_error 'ctx: target path is empty'
    return 1
  fi

  case $target in
    /|'')
      zshmq_log_error 'ctx: refusing to operate on root directory'
      return 1
      ;;
  esac

  printf '%s\n' "${target%/}"
}

ctx_new_impl() {
  runtime_root=$1

  if [ ! -d "$runtime_root" ]; then
    mkdir -p "$runtime_root"
  fi

  zshmq_log_debug 'ctx new: initialised runtime=%s' "$runtime_root"
}

ctx_destroy_impl() {
  runtime_root=$1
  force=$2

  if [ ! -d "$runtime_root" ]; then
    zshmq_log_debug 'ctx destroy: runtime not found (%s)' "$runtime_root"
    return 0
  fi

  if [ "$force" = "1" ]; then
    rm -rf "$runtime_root"
    zshmq_log_debug 'ctx destroy: forcefully removed runtime=%s' "$runtime_root"
    return 0
  fi

  pid_override=${ZSHMQ_TOPIC_PID:-${ZSHMQ_DISPATCH_PID:-}}
  if [ -n "$pid_override" ]; then
    pid_path=$pid_override
    if [ -f "$pid_path" ]; then
      rm -f "$pid_path"
      zshmq_log_debug 'ctx destroy: removed pid=%s' "$pid_path"
    else
      zshmq_log_trace 'ctx destroy: pid missing (%s)' "$pid_path"
    fi
  else
    removed_pid=0
    for candidate in "$runtime_root"/*.pid; do
      if [ -f "$candidate" ]; then
        rm -f "$candidate"
        zshmq_log_debug 'ctx destroy: removed pid=%s' "$candidate"
        removed_pid=1
      fi
    done
    if [ "$removed_pid" -eq 0 ]; then
      zshmq_log_trace 'ctx destroy: pid missing (%s/*.pid)' "$runtime_root"
    fi
  fi

  remaining=$(find "$runtime_root" -mindepth 1 -maxdepth 1 -not -name '.' -not -name '..' -print -quit 2>/dev/null || :)
  if [ -n "${remaining:-}" ]; then
    zshmq_log_error 'ctx destroy: runtime contains files; re-run with --force to remove %s' "$runtime_root"
    return 1
  fi

  if ! rmdir "$runtime_root" 2>/dev/null; then
    zshmq_log_error 'ctx destroy: failed to remove directory %s' "$runtime_root"
    return 1
  fi

  zshmq_log_debug 'ctx destroy: cleaned runtime=%s' "$runtime_root"
}

ctx() {
  set -eu

  log_level=${ZSHMQ_LOG_LEVEL:-INFO}
  target_path=${ZSHMQ_CTX_ROOT:-/tmp/zshmq}

  while [ $# -gt 0 ]; do
    case $1 in
      -p|--path)
        shift
        if [ $# -eq 0 ]; then
          zshmq_log_error 'ctx: --path requires a value'
          return 1
        fi
        target_path=$1
        ;;
      -p=*|--path=*)
        target_path=${1#*=}
        ;;
      -d|--debug)
        log_level=DEBUG
        ;;
      -t|--trace)
        log_level=TRACE
        ;;
      -h|--help|help)
        ctx_print_usage
        return 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        zshmq_log_error 'ctx: unexpected option -- %s' "$1"
        return 1
        ;;
      *)
        break
        ;;
    esac
    shift || :
  done

  export ZSHMQ_LOG_LEVEL=$log_level

  if [ $# -eq 0 ]; then
    ctx_print_usage
    return 1
  fi

  subcommand=$1
  shift

  runtime_root=$(ctx_resolve_target "$target_path") || return 1

  case $subcommand in
    new)
      if [ $# -gt 0 ]; then
        zshmq_log_error 'ctx new: unexpected argument -- %s' "$1"
        return 1
      fi
      ctx_new_impl "$runtime_root"
      ;;
    destroy)
      force=0
      while [ $# -gt 0 ]; do
        case $1 in
          -f|--force)
            force=1
            ;;
          -h|--help|help)
            ctx_print_usage
            return 0
            ;;
          --)
            shift
            break
            ;;
          -*)
            zshmq_log_error 'ctx destroy: unexpected option -- %s' "$1"
            return 1
            ;;
          *)
            zshmq_log_error 'ctx destroy: unexpected argument -- %s' "$1"
            return 1
            ;;
        esac
        shift || :
      done

      if [ $# -gt 0 ]; then
        zshmq_log_error 'ctx destroy: unexpected argument -- %s' "$1"
        return 1
      fi

      ctx_destroy_impl "$runtime_root" "$force"
      ;;
    *)
      zshmq_log_error 'ctx: unknown command -- %s' "$subcommand"
      ctx_print_usage
      return 1
      ;;
  esac
}

if command -v zshmq_register_command >/dev/null 2>&1; then
  zshmq_register_command ctx
fi

# shellcheck shell=sh

#/**
# topic send - Publish a message to the zshmq dispatcher.
# @usage: zshmq topic send --topic TOPIC [--path PATH] MESSAGE...
# @summary: Publish a message through the dispatcher FIFO.
# @description: Validate the runtime directory, ensure the dispatcher is running, and write the message to the topic-specific FIFO so subscribers receive it.
# @option: -p, --path PATH    Runtime directory to target (defaults to $ZSHMQ_CTX_ROOT or /tmp/zshmq).
# @option: -T, --topic TOPIC  Topic name for the published message (required).
# @option: -d, --debug        Enable DEBUG log level.
# @option: -t, --trace        Enable TRACE log level.
# @option: -h, --help         Display command documentation and exit.
#*/

topic_send_parser_definition() {
  zshmq_parser_defaults
  param CTX_PATH -p --path -- 'Runtime directory to target'
  param TOPIC_SEND_TOPIC -T --topic -- 'Explicit topic to apply'
}

topic_send_trim() {
  # Trim leading and trailing whitespace in a POSIX-safe way.
  printf '%s' "$1" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

topic_send() {
  set -eu

  if ! command -v getoptions >/dev/null 2>&1; then
    if [ -z "${ZSHMQ_ROOT:-}" ]; then
      zshmq_log_error 'topic send: ZSHMQ_ROOT is not set'
      return 1
    fi
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_base.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_abbr.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_help.sh"
  fi

  ZSHMQ_PARSER_USAGE='zshmq topic send --topic TOPIC [--path PATH] MESSAGE...'

  set +e
  zshmq_eval_parser topic_send topic_send_parser_definition "$@"
  status=$?
  set -e

  case $status in
    0)
      eval "set -- $ZSHMQ_REST"
      ;;
    1)
      return 1
      ;;
    2)
      return 0
      ;;
  esac

  topic=${TOPIC_SEND_TOPIC:-}
  if [ -z "$topic" ]; then
    zshmq_log_error 'topic send: --topic is required'
    return 1
  fi

  if [ $# -eq 0 ]; then
    zshmq_log_error 'topic send: message is required'
    return 1
  fi

  message=$1
  shift
  if [ $# -gt 0 ]; then
    message="$message $*"
  fi

  topic=$(topic_send_trim "$topic")
  if [ -z "$topic" ]; then
    zshmq_log_error 'topic send: topic must not be empty'
    return 1
  fi

  case $topic in
    *'|'*)
      zshmq_log_error 'topic send: topic must not contain "|"'
      return 1
      ;;
  esac

  target=${CTX_PATH:-${ZSHMQ_CTX_ROOT:-/tmp/zshmq}}

  if [ -z "$target" ]; then
    zshmq_log_error 'topic send: target path is empty'
    return 1
  fi

  case $target in
    /|'')
      zshmq_log_error 'topic send: refusing to operate on root directory'
      return 1
      ;;
  esac

  runtime_root=${target%/}
  topic_fifo_path=${ZSHMQ_TOPIC:-${runtime_root}/${topic}.fifo}
  pid_path=${ZSHMQ_TOPIC_PID:-${ZSHMQ_DISPATCH_PID:-${runtime_root}/${topic}.pid}}

  if [ ! -d "$target" ]; then
    zshmq_log_error 'topic send: runtime directory not found: %s' "$target"
    return 1
  fi

  if [ ! -p "$topic_fifo_path" ]; then
    zshmq_log_error 'topic send: topic FIFO not found at %s' "$topic_fifo_path"
    return 1
  fi

  if [ -f "$pid_path" ]; then
    dispatcher_pid=$(tr -d '\r\n' < "$pid_path" 2>/dev/null || :)
  else
    dispatcher_pid=
  fi

  if [ -z "$dispatcher_pid" ] || ! kill -0 "$dispatcher_pid" 2>/dev/null; then
    zshmq_log_error 'topic send: dispatcher is not running'
    return 1
  fi

  zshmq_log_trace 'topic send: topic=%s message=%s' "$topic" "$message"
  printf 'PUB|%s|%s\n' "$topic" "$message" > "$topic_fifo_path"
}

# shellcheck shell=sh

#/**
# topic start - Launch the dispatcher loop for a topic.
# @usage: zshmq topic start --topic TOPIC [--path PATH]
# @summary: Spawn the topic dispatcher (default runtime: /tmp/zshmq) in the background.
# @description: Validates a runtime directory created by `ctx new`, then spawns the dispatcher loop so publishers and subscribers can exchange messages via the topic FIFO. Supports foreground mode for debugging.
# @option: -p, --path PATH    Runtime directory to target (defaults to $ZSHMQ_CTX_ROOT or /tmp/zshmq).
# @option: -T, --topic TOPIC  Topic name handled by this dispatcher.
# @option: -f, --foreground   Run the dispatcher in the foreground.
# @option: -d, --debug        Enable DEBUG log level.
# @option: -t, --trace        Enable TRACE log level.
# @option: -h, --help         Display command documentation and exit.
#*/

:

# shellcheck shell=sh

#/**
# topic stop - Terminate the dispatcher loop for a topic.
# @usage: zshmq topic stop --topic TOPIC [--path PATH]
# @summary: Stop the dispatcher that serves a topic and remove its PID file.
# @description: Looks up the dispatcher PID for the requested topic (or via environment overrides), sends a termination signal, waits briefly for shutdown, and cleans up PID artifacts. No-op when the dispatcher is already stopped.
# @option: -p, --path PATH    Runtime directory to target (defaults to $ZSHMQ_CTX_ROOT or /tmp/zshmq).
# @option: -T, --topic TOPIC  Topic name whose dispatcher should be stopped.
# @option: -d, --debug        Enable DEBUG log level.
# @option: -t, --trace        Enable TRACE log level.
# @option: -h, --help         Display command documentation and exit.
#*/

:

# shellcheck shell=sh

#/**
# topic sub - Subscribe to messages for a specific topic.
# @usage: zshmq topic sub --topic TOPIC [--path PATH]
# @summary: Register a subscriber FIFO and stream dispatched messages for TOPIC.
# @description: Validate the runtime directory, ensure the dispatcher is running, register the subscription with the dispatcher, and stream messages until interrupted.
# @option: -p, --path PATH    Runtime directory to target (defaults to $ZSHMQ_CTX_ROOT or /tmp/zshmq).
# @option: -T, --topic TOPIC  Topic name to subscribe to.
# @option: -d, --debug        Enable DEBUG log level.
# @option: -t, --trace        Enable TRACE log level.
# @option: -h, --help         Display command documentation and exit.
#*/

topic_sub_parser_definition() {
  zshmq_parser_defaults
  param CTX_PATH -p --path -- 'Runtime directory to target'
  param TOPIC_SUB_TOPIC -T --topic -- 'Topic name to subscribe to'
}

topic_sub_extract_fifo_pid() {
  fifo_path=$1
  name=${fifo_path##*/}
  pid=${name##*.}
  case $pid in
    ''|*[!0-9]*)
      printf '%s\n' ''
      return 1
      ;;
  esac
  printf '%s\n' "$pid"
  return 0
}

topic_sub_prune_state() {
  state_path=$1
  tmp_state="${state_path}.prune.$$"
  : > "$tmp_state"
  while IFS= read -r existing_fifo || [ -n "$existing_fifo" ]; do
    [ -n "$existing_fifo" ] || continue
    fifo_pid=$(topic_sub_extract_fifo_pid "$existing_fifo")
    if [ -n "$fifo_pid" ] && kill -0 "$fifo_pid" 2>/dev/null; then
      if [ -p "$existing_fifo" ]; then
        printf '%s\n' "$existing_fifo" >> "$tmp_state"
      fi
    else
      rm -f "$existing_fifo" 2>/dev/null || :
    fi
  done < "$state_path"
  mv "$tmp_state" "$state_path"
}

topic_sub_cleanup() {
  if [ "${TOPIC_SUB_CLEANED:-0}" -eq 1 ]; then
    return 0
  fi
  TOPIC_SUB_CLEANED=1

  if [ -n "${TOPIC_SUB_FIFO_FD:-}" ]; then
    eval "exec ${TOPIC_SUB_FIFO_FD}>&-" 2>/dev/null || :
  fi

  if [ "${TOPIC_SUB_REGISTERED:-0}" -eq 1 ] && [ -n "${TOPIC_SUB_TOPIC_FIFO_PATH:-}" ] && [ -n "${TOPIC_SUB_FIFO_PATH:-}" ]; then
    if [ -n "${TOPIC_SUB_DISPATCHER_PID:-}" ] && kill -0 "$TOPIC_SUB_DISPATCHER_PID" 2>/dev/null; then
      { printf 'UNSUB|%s\n' "$TOPIC_SUB_FIFO_PATH"; } > "$TOPIC_SUB_TOPIC_FIFO_PATH" 2>/dev/null || :
    fi
    TOPIC_SUB_REGISTERED=0
  fi

  if [ -n "${TOPIC_SUB_STATE_PATH:-}" ] && [ -f "${TOPIC_SUB_STATE_PATH:-}" ]; then
    tmp_state="${TOPIC_SUB_STATE_PATH}.tmp.$$"
    : > "$tmp_state"
    while IFS= read -r state_line || [ -n "$state_line" ]; do
      [ -n "$state_line" ] || continue
      state_fifo=$state_line
      if [ "$state_fifo" = "${TOPIC_SUB_FIFO_PATH:-}" ]; then
        rm -f "$state_fifo" 2>/dev/null || :
        continue
      fi
      fifo_pid=$(topic_sub_extract_fifo_pid "$state_fifo")
      if [ -n "$fifo_pid" ] && kill -0 "$fifo_pid" 2>/dev/null; then
        if [ -p "$state_fifo" ]; then
          printf '%s\n' "$state_fifo" >> "$tmp_state"
        fi
      else
        rm -f "$state_fifo" 2>/dev/null || :
      fi
    done < "${TOPIC_SUB_STATE_PATH}"
    mv "$tmp_state" "${TOPIC_SUB_STATE_PATH}"
  fi

  if [ -n "${TOPIC_SUB_FIFO_PATH:-}" ] && [ -e "$TOPIC_SUB_FIFO_PATH" ]; then
    rm -f "$TOPIC_SUB_FIFO_PATH" 2>/dev/null || :
  fi
}

topic_sub() {
  set -eu

  if ! command -v getoptions >/dev/null 2>&1; then
    if [ -z "${ZSHMQ_ROOT:-}" ]; then
      zshmq_log_error 'topic sub: ZSHMQ_ROOT is not set'
      return 1
    fi
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_base.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_abbr.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_help.sh"
  fi

  ZSHMQ_PARSER_USAGE='zshmq topic sub --topic TOPIC [--path PATH]'

  set +e
  zshmq_eval_parser topic_sub topic_sub_parser_definition "$@"
  status=$?
  set -e

  case $status in
    0)
      eval "set -- $ZSHMQ_REST"
      ;;
    1)
      return 1
      ;;
    2)
      return 0
      ;;
  esac

  if [ $# -gt 0 ]; then
    zshmq_log_error 'topic sub: unexpected argument -- %s' "$1"
    return 1
  fi

  topic=${TOPIC_SUB_TOPIC:-}
  if [ -z "$topic" ]; then
    zshmq_log_error 'topic sub: --topic is required'
    return 1
  fi

  target=${CTX_PATH:-${ZSHMQ_CTX_ROOT:-/tmp/zshmq}}

  if [ -z "$target" ]; then
    zshmq_log_error 'topic sub: target path is empty'
    return 1
  fi

  case $target in
    /|'')
      zshmq_log_error 'topic sub: refusing to operate on root directory'
      return 1
      ;;
  esac

  if [ ! -d "$target" ]; then
    zshmq_log_error 'topic sub: runtime directory not found: %s' "$target"
    return 1
  fi

  runtime_root=${target%/}
  state_path=${ZSHMQ_STATE:-${runtime_root}/${topic}.state}
  topic_fifo_path=${ZSHMQ_TOPIC:-${runtime_root}/${topic}.fifo}
  pid_path=${ZSHMQ_TOPIC_PID:-${ZSHMQ_DISPATCH_PID:-${runtime_root}/${topic}.pid}}

  if [ ! -f "$state_path" ]; then
    zshmq_log_error 'topic sub: state file not found at %s' "$state_path"
    return 1
  fi

  if [ ! -p "$topic_fifo_path" ]; then
    zshmq_log_error 'topic sub: topic FIFO not found at %s' "$topic_fifo_path"
    return 1
  fi

  if [ ! -f "$pid_path" ]; then
    zshmq_log_error 'topic sub: dispatcher pid file not found at %s' "$pid_path"
    return 1
  fi

  dispatcher_pid=$(tr -d '\r\n' < "$pid_path" 2>/dev/null || :)
  if [ -z "$dispatcher_pid" ] || ! kill -0 "$dispatcher_pid" 2>/dev/null; then
    zshmq_log_error 'topic sub: dispatcher is not running'
    return 1
  fi

  TOPIC_SUB_DISPATCHER_PID=$dispatcher_pid

  fifo_path=${runtime_root}/${topic}.$$
  if [ -e "$fifo_path" ]; then
    zshmq_log_error 'topic sub: subscriber fifo already exists at %s' "$fifo_path"
    return 1
  fi

  if ! mkfifo "$fifo_path"; then
    zshmq_log_error 'topic sub: failed to create fifo at %s' "$fifo_path"
    return 1
  fi

  TOPIC_SUB_TOPIC_FIFO_PATH=$topic_fifo_path
  TOPIC_SUB_FIFO_PATH=$fifo_path
  TOPIC_SUB_FIFO_FD=9
  TOPIC_SUB_CLEANED=0
  TOPIC_SUB_REGISTERED=0
  TOPIC_SUB_STATE_PATH=$state_path

  if [ -s "$state_path" ]; then
    topic_sub_prune_state "$state_path"
  fi

  trap 'topic_sub_cleanup; exit 130' INT
  trap 'topic_sub_cleanup; exit 143' TERM
  trap 'topic_sub_cleanup; exit 129' HUP
  trap 'topic_sub_cleanup' EXIT

  if ! { printf 'SUB|%s\n' "$fifo_path"; } > "$topic_fifo_path"; then
    zshmq_log_error 'topic sub: failed to register with dispatcher'
    topic_sub_cleanup
    return 1
  fi
  TOPIC_SUB_REGISTERED=1

  if ! exec 9<>"$fifo_path"; then
    zshmq_log_error 'topic sub: unable to open fifo for reading'
    topic_sub_cleanup
    return 1
  fi

  zshmq_log_debug 'topic sub: subscribed to topic=%s fifo=%s' "$topic" "$fifo_path"

  while IFS= read -r line <&9 || [ -n "$line" ]; do
    zshmq_log_trace 'topic sub: received topic=%s message=%s' "$topic" "$line"
    printf '%s\n' "$line"
  done

  topic_sub_cleanup
}

# shellcheck shell=sh

#/**
# topic - Manage topic assets within a runtime directory.
# @usage: zshmq topic <command> [options]
# @summary: Manage topic FIFOs and state files.
# @description: Provides subcommands to provision or remove the FIFO/state pair used by publishers and subscribers for a topic.
# @option: -p, --path PATH    Runtime directory to target (defaults to $ZSHMQ_CTX_ROOT or /tmp/zshmq).
# @option: --regex REGEX      (topic new/destroy) Optional routing regex recorded in the topics registry.
# @option: -d, --debug        Enable DEBUG log level.
# @option: -t, --trace        Enable TRACE log level.
# @option: -h, --help         Display command documentation and exit.
#*/

topic_print_usage() {
  printf '%s\n' 'Usage: zshmq topic <command> [options]'
  printf '%s\n' ''
  printf '%s\n' 'Commands:'
  printf '  new      Initialise topic assets (-T/--topic required)\n'
  printf '  destroy  Remove topic assets    (-T/--topic required)\n'
  printf '  start    Launch the topic dispatcher (-T/--topic required)\n'
  printf '  stop     Terminate the topic dispatcher (-T/--topic required)\n'
  printf '  send     Publish a message      (-T/--topic required)\n'
  printf '  sub      Stream topic messages  (-T/--topic required)\n'
}

topic_registry_path() {
  runtime_root=$1
  printf '%s\n' "${runtime_root}/topics.reg"
}

topic_registry_normalize_regex() {
  printf '%s' "$1" | tr -d '\r'
}

topic_registry_upsert() {
  runtime_root=$1
  topic_name=$2
  topic_regex=$3

  registry_path=$(topic_registry_path "$runtime_root")
  tmp_registry="${registry_path}.tmp.$$"
  registry_dir=${registry_path%/*}
  if [ ! -d "$registry_dir" ]; then
    mkdir -p "$registry_dir"
  fi
  touch "$registry_path"

  found=0
  : > "$tmp_registry"

  while IFS= read -r registry_line || [ -n "$registry_line" ]; do
    # Preserve lines unrelated to topics (e.g. comments).
    case $registry_line in
      '')
        printf '\n' >> "$tmp_registry"
        continue
        ;;
      \#*)
        printf '%s\n' "$registry_line" >> "$tmp_registry"
        continue
        ;;
    esac
    entry_topic=$registry_line
    entry_regex=
    case $registry_line in
      *'	'*)
        entry_topic=${registry_line%%	*}
        entry_regex=${registry_line#*	}
        ;;
    esac
    if [ "$entry_topic" = "$topic_name" ]; then
      found=1
      normalized_regex=$(topic_registry_normalize_regex "$topic_regex")
      printf '%s\t%s\n' "$topic_name" "$normalized_regex" >> "$tmp_registry"
    else
      printf '%s\n' "$registry_line" >> "$tmp_registry"
    fi
  done < "$registry_path"

  if [ "$found" -eq 0 ]; then
    normalized_regex=$(topic_registry_normalize_regex "$topic_regex")
    printf '%s\t%s\n' "$topic_name" "$normalized_regex" >> "$tmp_registry"
  fi

  mv "$tmp_registry" "$registry_path"
}

topic_registry_remove() {
  runtime_root=$1
  topic_name=$2

  registry_path=$(topic_registry_path "$runtime_root")
  if [ ! -f "$registry_path" ]; then
    return 0
  fi

  tmp_registry="${registry_path}.tmp.$$"
  removed=0
  : > "$tmp_registry"

  while IFS= read -r registry_line || [ -n "$registry_line" ]; do
    case $registry_line in
      '')
        printf '\n' >> "$tmp_registry"
        continue
        ;;
      \#*)
        printf '%s\n' "$registry_line" >> "$tmp_registry"
        continue
        ;;
    esac
    entry_topic=$registry_line
    case $registry_line in
      *'	'*)
        entry_topic=${registry_line%%	*}
        ;;
    esac
    if [ "$entry_topic" = "$topic_name" ]; then
      removed=1
      continue
    fi
    printf '%s\n' "$registry_line" >> "$tmp_registry"
  done < "$registry_path"

  mv "$tmp_registry" "$registry_path"
  if [ "$removed" -eq 1 ]; then
    return 0
  fi
  return 1
}

topic_require_topic() {
  subcommand=$1
  shift

  topic_name=
  topic_regex=

  while [ $# -gt 0 ]; do
    case $1 in
      -T|--topic)
        shift
        if [ $# -eq 0 ]; then
          zshmq_log_error 'topic %s: --topic requires a value' "$subcommand"
          return 1
        fi
        topic_name=$1
        ;;
      -T=*|--topic=*)
        topic_name=${1#*=}
        ;;
      --regex)
        shift
        if [ $# -eq 0 ]; then
          zshmq_log_error 'topic %s: --regex requires a value' "$subcommand"
          return 1
        fi
        topic_regex=$1
        ;;
      --regex=*)
        topic_regex=${1#*=}
        ;;
      --)
        shift
        break
        ;;
      -*)
        zshmq_log_error 'topic %s: unexpected option -- %s' "$subcommand" "$1"
        return 1
        ;;
      *)
        zshmq_log_error 'topic %s: unexpected argument -- %s' "$subcommand" "$1"
        return 1
        ;;
    esac
    shift
  done

  if [ $# -gt 0 ]; then
    zshmq_log_error 'topic %s: unexpected argument -- %s' "$subcommand" "$1"
    return 1
  fi

  if [ -z "${topic_name:-}" ]; then
    zshmq_log_error 'topic %s: --topic is required' "$subcommand"
    return 1
  fi

  case $topic_name in
    *'|'*)
      zshmq_log_error 'topic %s: topic must not contain "|"' "$subcommand"
      return 1
      ;;
    *'	'*)
      zshmq_log_error 'topic %s: topic must not contain tabs' "$subcommand"
      return 1
      ;;
    *'/'*)
      zshmq_log_error 'topic %s: topic must not contain "/"' "$subcommand"
      return 1
      ;;
    *'
'*)
      zshmq_log_error 'topic %s: topic must not contain newlines' "$subcommand"
      return 1
      ;;
  esac

  TOPIC_NAME=$topic_name
  TOPIC_REGEX=$topic_regex
}

topic_ensure_runtime() {
  path=$1

  if [ -z "$path" ]; then
    zshmq_log_error 'topic: target path is empty'
    return 1
  fi

  case $path in
    /|'')
      zshmq_log_error 'topic: refusing to operate on root directory'
      return 1
      ;;
  esac

  if [ ! -d "$path" ]; then
    zshmq_log_error 'topic: runtime directory not found: %s' "$path"
    return 1
  fi

  printf '%s\n' "${path%/}"
}

topic_new() {
  runtime_root=$1
  topic_name=$2
  topic_regex=${3-}

  state_path=${ZSHMQ_STATE:-${runtime_root}/${topic_name}.state}
  topic_fifo_path=${ZSHMQ_TOPIC:-${runtime_root}/${topic_name}.fifo}

  case $state_path in
    */*)
      state_dir=${state_path%/*}
      ;;
    *)
      state_dir=.
      ;;
  esac
  if [ "$state_dir" != "." ] && [ ! -d "$state_dir" ]; then
    mkdir -p "$state_dir"
  fi

  if [ -e "$state_path" ] && [ ! -f "$state_path" ]; then
    zshmq_log_error 'topic new: state path is not a regular file: %s' "$state_path"
    return 1
  fi
  : > "$state_path"

  case $topic_fifo_path in
    */*)
      topic_dir=${topic_fifo_path%/*}
      ;;
    *)
      topic_dir=.
      ;;
  esac
  if [ "$topic_dir" != "." ] && [ ! -d "$topic_dir" ]; then
    mkdir -p "$topic_dir"
  fi

  if [ -e "$topic_fifo_path" ]; then
    if [ -p "$topic_fifo_path" ]; then
      rm -f "$topic_fifo_path"
    else
      zshmq_log_error 'topic new: topic FIFO path is not a FIFO: %s' "$topic_fifo_path"
      return 1
    fi
  fi

  if ! mkfifo "$topic_fifo_path"; then
    zshmq_log_error 'topic new: failed to create fifo at %s' "$topic_fifo_path"
    return 1
  fi

  topic_registry_upsert "$runtime_root" "$topic_name" "$topic_regex"

  zshmq_log_debug 'topic new: initialised topic=%s runtime=%s' "$topic_name" "$runtime_root"
}

topic_destroy() {
  runtime_root=$1
  topic_name=$2
  topic_regex=${3-}

  state_path=${ZSHMQ_STATE:-${runtime_root}/${topic_name}.state}
  topic_fifo_path=${ZSHMQ_TOPIC:-${runtime_root}/${topic_name}.fifo}

  if [ -f "$state_path" ]; then
    rm -f "$state_path"
    zshmq_log_debug 'topic destroy: removed state=%s' "$state_path"
  else
    zshmq_log_trace 'topic destroy: state missing (%s)' "$state_path"
  fi

  if [ -p "$topic_fifo_path" ] || [ -f "$topic_fifo_path" ]; then
    rm -f "$topic_fifo_path"
    zshmq_log_debug 'topic destroy: removed fifo=%s' "$topic_fifo_path"
  else
    zshmq_log_trace 'topic destroy: fifo missing (%s)' "$topic_fifo_path"
  fi

  if topic_registry_remove "$runtime_root" "$topic_name"; then
    zshmq_log_debug 'topic destroy: removed registry entry topic=%s' "$topic_name"
  else
    zshmq_log_trace 'topic destroy: registry entry missing topic=%s' "$topic_name"
  fi
}

dispatcher_extract_fifo_pid() {
  fifo_path=$1
  name=${fifo_path##*/}
  pid=${name##*.}
  case $pid in
    ''|*[!0-9]*)
      printf '%s\n' ''
      return 1
      ;;
  esac
  printf '%s\n' "$pid"
  return 0
}

dispatcher_prune_state() {
  state_path=$1
  tmp_state="${state_path}.dispatcher.$$"
  : > "$tmp_state"
  while IFS= read -r fifo || [ -n "$fifo" ]; do
    [ -n "$fifo" ] || continue
    fifo_pid=$(dispatcher_extract_fifo_pid "$fifo")
    if [ -n "$fifo_pid" ] && kill -0 "$fifo_pid" 2>/dev/null; then
      if [ -p "$fifo" ]; then
        printf '%s\n' "$fifo" >> "$tmp_state"
      fi
    else
      rm -f "$fifo" 2>/dev/null || :
    fi
  done < "$state_path"
  mv "$tmp_state" "$state_path"
}

zshmq_dispatch_loop() {
  topic_fifo_path=$1
  state_path=$2

  trap 'exec 3>&-; exit 0' INT TERM HUP

  # Keep the FIFO open even when no writers are connected.
  exec 3<>"$topic_fifo_path"

  while IFS= read -r line <&3; do
    case $line in
      SUB\|*)
        entry=${line#SUB|}
        if [ -n "$entry" ]; then
          [ -f "$state_path" ] || : > "$state_path"
          if ! grep -F -- "$entry" "$state_path" >/dev/null 2>&1; then
            printf '%s\n' "$entry" >> "$state_path"
          fi
        fi
        ;;
      UNSUB\|*)
        entry=${line#UNSUB|}
        if [ -n "$entry" ] && [ -f "$state_path" ]; then
          tmp_state="${state_path}.tmp.$$"
          : > "$tmp_state"
          while IFS= read -r state_line || [ -n "$state_line" ]; do
            [ "$state_line" = "$entry" ] && continue
            printf '%s\n' "$state_line" >> "$tmp_state"
          done < "$state_path"
          mv "$tmp_state" "$state_path"
        fi
        ;;
      PUB\|*)
        payload=${line#PUB|}
        topic=${payload%%|*}
        message=${payload#*|}
        if [ -f "$state_path" ] && [ -n "$topic" ]; then
          message_body=$message
          if [ -s "$state_path" ]; then
            dispatcher_prune_state "$state_path"
          fi
          zshmq_log_trace 'dispatcher: topic=%s message=%s' "$topic" "$message_body"
          while IFS= read -r fifo_path || [ -n "$fifo_path" ]; do
            [ -n "$fifo_path" ] || continue
            fifo_pid=$(dispatcher_extract_fifo_pid "$fifo_path")
            if [ -z "$fifo_pid" ] || ! kill -0 "$fifo_pid" 2>/dev/null; then
              continue
            fi
            if [ -p "$fifo_path" ]; then
              zshmq_log_trace 'dispatcher: deliver topic=%s message=%s fifo=%s' "$topic" "$message_body" "$fifo_path"
              { printf '%s\n' "$message_body"; } >> "$fifo_path" 2>/dev/null || :
            fi
          done < "$state_path"
        fi
        ;;
      *)
        :
        ;;
    esac
  done
}

topic_start_parser_definition() {
  zshmq_parser_defaults
  param TOPIC_START_CTX_PATH -p --path -- 'Runtime directory to target'
  param TOPIC_START_TOPIC -T --topic -- 'Topic name handled by this dispatcher'
  flag TOPIC_START_FOREGROUND -f --foreground -- 'Run the dispatcher in the foreground'
}

topic_start_cmd() {
  set -eu

  if ! command -v getoptions >/dev/null 2>&1; then
    if [ -z "${ZSHMQ_ROOT:-}" ]; then
      zshmq_log_error 'topic start: ZSHMQ_ROOT is not set'
      return 1
    fi
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_base.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_abbr.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_help.sh"
  fi

  unset TOPIC_START_FOREGROUND || :

  set +e
  zshmq_eval_parser topic_start topic_start_parser_definition "$@"
  status=$?
  set -e

  case $status in
    0)
      eval "set -- $ZSHMQ_REST"
      ;;
    1)
      return 1
      ;;
    2)
      return 0
      ;;
  esac

  if [ $# -gt 0 ]; then
    zshmq_log_error 'topic start: unexpected argument -- %s' "$1"
    return 1
  fi

  unset ZSHMQ_REST || :

  topic=${TOPIC_START_TOPIC:-}
  if [ -z "$topic" ]; then
    zshmq_log_error 'topic start: --topic is required'
    return 1
  fi

  target=${TOPIC_START_CTX_PATH:-${ZSHMQ_CTX_ROOT:-/tmp/zshmq}}

  if [ -z "$target" ]; then
    zshmq_log_error 'topic start: target path is empty'
    return 1
  fi

  case $target in
    /|'')
      zshmq_log_error 'topic start: refusing to operate on root directory'
      return 1
      ;;
  esac

  runtime_root=${target%/}
  state_path=${ZSHMQ_STATE:-${runtime_root}/${topic}.state}
  topic_fifo_path=${ZSHMQ_TOPIC:-${runtime_root}/${topic}.fifo}
  pid_path=${ZSHMQ_TOPIC_PID:-${ZSHMQ_DISPATCH_PID:-${runtime_root}/${topic}.pid}}

  if [ ! -d "$target" ]; then
    zshmq_log_error 'topic start: runtime directory not found: %s' "$target"
    return 1
  fi

  if [ ! -p "$topic_fifo_path" ]; then
    zshmq_log_error 'topic start: topic FIFO not found at %s' "$topic_fifo_path"
    return 1
  fi

  if [ ! -f "$state_path" ]; then
    zshmq_log_error 'topic start: state file not found at %s' "$state_path"
    return 1
  fi

  if [ -f "$pid_path" ]; then
    existing_pid=$(tr -d '\r\n' < "$pid_path" 2>/dev/null || :)
    if [ -n "$existing_pid" ] && kill -0 "$existing_pid" 2>/dev/null; then
      zshmq_log_debug 'topic start: dispatcher already running (pid=%s)' "$existing_pid"
      return 1
    fi
    rm -f "$pid_path"
  fi

  if [ "${TOPIC_START_FOREGROUND:-0}" = "1" ]; then
    zshmq_dispatch_loop "$topic_fifo_path" "$state_path" &
    dispatcher_pid=$!
    printf '%s\n' "$dispatcher_pid" > "$pid_path"
    zshmq_log_debug 'topic start: dispatcher started (pid=%s)' "$dispatcher_pid"

    topic_start_cleaned=0

    topic_start_cleanup() {
      if [ "${topic_start_cleaned}" -eq 1 ]; then
        return 0
      fi
      topic_start_cleaned=1
      trap - INT TERM HUP EXIT
      if [ -n "${dispatcher_pid:-}" ] && kill -0 "$dispatcher_pid" 2>/dev/null; then
        kill "$dispatcher_pid" 2>/dev/null || :
        wait "$dispatcher_pid" 2>/dev/null || :
      else
        wait "$dispatcher_pid" 2>/dev/null || :
      fi
      rm -f "$pid_path"
    }

    trap 'topic_start_cleanup; exit 130' INT
    trap 'topic_start_cleanup; exit 143' TERM
    trap 'topic_start_cleanup; exit 129' HUP
    trap 'topic_start_cleanup' EXIT

    wait "$dispatcher_pid"
    wait_status=$?
    topic_start_cleanup
    return "$wait_status"
  fi

  zshmq_dispatch_loop "$topic_fifo_path" "$state_path" &
  dispatcher_pid=$!
  printf '%s\n' "$dispatcher_pid" > "$pid_path"
  zshmq_log_debug 'topic start: dispatcher started (pid=%s)' "$dispatcher_pid"
}

topic_stop_parser_definition() {
  zshmq_parser_defaults
  param TOPIC_STOP_CTX_PATH -p --path -- 'Runtime directory to target'
  param TOPIC_STOP_TOPIC -T --topic -- 'Topic name whose dispatcher should be stopped'
}

topic_stop_cmd() {
  set -eu

  if ! command -v getoptions >/dev/null 2>&1; then
    if [ -z "${ZSHMQ_ROOT:-}" ]; then
      zshmq_log_error 'topic stop: ZSHMQ_ROOT is not set'
      return 1
    fi
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_base.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_abbr.sh"
    # shellcheck disable=SC1090
    . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_help.sh"
  fi

  set +e
  zshmq_eval_parser topic_stop topic_stop_parser_definition "$@"
  status=$?
  set -e

  case $status in
    0)
      eval "set -- $ZSHMQ_REST"
      ;;
    1)
      return 1
      ;;
    2)
      return 0
      ;;
  esac

  if [ $# -gt 0 ]; then
    zshmq_log_error 'topic stop: unexpected argument -- %s' "$1"
    return 1
  fi

  unset ZSHMQ_REST || :

  topic=${TOPIC_STOP_TOPIC:-}
  pid_override=
  if [ -z "$topic" ] && [ -n "${ZSHMQ_TOPIC:-}" ]; then
    topic_source=$ZSHMQ_TOPIC
    topic_basename=${topic_source##*/}
    topic=${topic_basename%.fifo}
    case $topic_source in
      /*)
        pid_override=${topic_source%.fifo}.pid
        ;;
      *)
        pid_override=
        ;;
    esac
  fi

  if [ -z "$topic" ]; then
    zshmq_log_error 'topic stop: --topic is required'
    return 1
  fi

  target=${TOPIC_STOP_CTX_PATH:-${ZSHMQ_CTX_ROOT:-/tmp/zshmq}}

  if [ -z "$target" ]; then
    zshmq_log_error 'topic stop: target path is empty'
    return 1
  fi

  case $target in
    /|'')
      zshmq_log_error 'topic stop: refusing to operate on root directory'
      return 1
      ;;
  esac

  runtime_root=${target%/}
  pid_env=${ZSHMQ_TOPIC_PID:-${ZSHMQ_DISPATCH_PID:-}}
  if [ -n "$pid_env" ]; then
    pid_path=$pid_env
  elif [ -n "$pid_override" ]; then
    pid_path=$pid_override
  else
    pid_path=${runtime_root}/${topic}.pid
  fi

  if [ -z "$pid_path" ] || [ ! -f "$pid_path" ]; then
    zshmq_log_debug 'topic stop: dispatcher is not running.'
    return 0
  fi

  dispatcher_pid=$(tr -d '\r\n' < "$pid_path" 2>/dev/null || :)
  if [ -z "$dispatcher_pid" ]; then
    rm -f "$pid_path"
    zshmq_log_debug 'topic stop: dispatcher is not running.'
    return 0
  fi

  if ! kill -0 "$dispatcher_pid" 2>/dev/null; then
    rm -f "$pid_path"
    zshmq_log_debug 'topic stop: dispatcher is not running.'
    return 0
  fi

  kill "$dispatcher_pid" 2>/dev/null || :

  for attempt in 1 2 3 4 5; do
    if ! kill -0 "$dispatcher_pid" 2>/dev/null; then
      break
    fi
    sleep 1
  done

  if kill -0 "$dispatcher_pid" 2>/dev/null; then
    zshmq_log_error 'topic stop: dispatcher (pid=%s) did not terminate' "$dispatcher_pid"
    return 1
  fi

  rm -f "$pid_path"
  zshmq_log_debug 'topic stop: dispatcher stopped (pid=%s)' "$dispatcher_pid"
}

topic() {
  set -eu

  log_level=${ZSHMQ_LOG_LEVEL:-INFO}
  target_path=${ZSHMQ_CTX_ROOT:-/tmp/zshmq}
  target_overridden=0

  export ZSHMQ_LOG_LEVEL=$log_level

  while [ $# -gt 0 ]; do
    case $1 in
      -p|--path)
        shift
        if [ $# -eq 0 ]; then
          zshmq_log_error 'topic: --path requires a value'
          return 1
        fi
        target_path=$1
        target_overridden=1
        ;;
      -p=*|--path=*)
        target_path=${1#*=}
        target_overridden=1
        ;;
      -d|--debug)
        log_level=DEBUG
        ;;
      -t|--trace)
        log_level=TRACE
        ;;
      -h|--help|help)
        topic_print_usage
        return 0
        ;;
      --)
        shift
        break
        ;;
      -*)
        zshmq_log_error 'topic: unexpected option -- %s' "$1"
        return 1
        ;;
      *)
        break
        ;;
    esac
    shift || :
  done

  export ZSHMQ_LOG_LEVEL=$log_level

  if [ $# -eq 0 ]; then
    topic_print_usage
    return 1
  fi

  subcommand=$1
  shift

  case $subcommand in
    new)
      runtime_root=$(topic_ensure_runtime "$target_path") || return 1
      unset TOPIC_REGEX || :
      unset TOPIC_NAME || :
      topic_require_topic "$subcommand" "$@" || return 1
      topic_name=${TOPIC_NAME-}
      topic_regex=${TOPIC_REGEX-}
      topic_new "$runtime_root" "$topic_name" "$topic_regex"
      ;;
    destroy)
      runtime_root=$(topic_ensure_runtime "$target_path") || return 1
      unset TOPIC_REGEX || :
      unset TOPIC_NAME || :
      topic_require_topic "$subcommand" "$@" || return 1
      topic_name=${TOPIC_NAME-}
      topic_regex=${TOPIC_REGEX-}
      topic_destroy "$runtime_root" "$topic_name" "$topic_regex"
      ;;
    start)
      if [ "$target_overridden" -eq 1 ]; then
        topic_start_cmd --path "$target_path" "$@"
      else
        topic_start_cmd "$@"
      fi
      ;;
    stop)
      if [ "$target_overridden" -eq 1 ]; then
        topic_stop_cmd --path "$target_path" "$@"
      else
        topic_stop_cmd "$@"
      fi
      ;;
    send)
      if [ "$target_overridden" -eq 1 ]; then
        CTX_PATH=$target_path topic_send "$@"
      else
        topic_send "$@"
      fi
      ;;
    sub)
      if [ "$target_overridden" -eq 1 ]; then
        CTX_PATH=$target_path topic_sub "$@"
      else
        topic_sub "$@"
      fi
      ;;
    -h|--help|help)
      topic_print_usage
      return 0
      ;;
    *)
      zshmq_log_error 'topic: unknown command -- %s' "$subcommand"
      topic_print_usage
      return 1
      ;;
  esac
}

if command -v zshmq_register_command >/dev/null 2>&1; then
  zshmq_register_command topic
fi

set -eu

script_dir=$(
  CDPATH= cd -- "$(dirname -- "$0")" && pwd
)
if [ -n "${ZSHMQ_EMBEDDED:-}" ]; then
  ZSHMQ_ROOT=${script_dir}
else
  ZSHMQ_ROOT=$(
    CDPATH= cd -- "${script_dir}/.." && pwd
  )
fi
export ZSHMQ_ROOT
export ZSHMQ_VERSION=${ZSHMQ_VERSION:-$( [ -f "${ZSHMQ_ROOT}/VERSION" ] && cat "${ZSHMQ_ROOT}/VERSION" || printf '%s\n' '0.0.1' )}

if [ -z "${ZSHMQ_EMBEDDED:-}" ]; then
  # Load getoptions once so command implementations can rely on it.
  # shellcheck disable=SC1090
  . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_base.sh"
  # shellcheck disable=SC1090
  . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_abbr.sh"
  # shellcheck disable=SC1090
  . "${ZSHMQ_ROOT}/vendor/getoptions/lib/getoptions_help.sh"
  # shellcheck disable=SC1091
  . "${ZSHMQ_ROOT}/lib/command_helpers.sh"
  # shellcheck disable=SC1091
  . "${ZSHMQ_ROOT}/lib/logging.sh"

  # Load command implementations after helper definitions.
  # shellcheck disable=SC1091
  . "${ZSHMQ_ROOT}/lib/ctx.sh"
  # shellcheck disable=SC1091
  . "${ZSHMQ_ROOT}/lib/topic.sh"
  # shellcheck disable=SC1091
  . "${ZSHMQ_ROOT}/lib/topic_send.sh"
  # shellcheck disable=SC1091
  . "${ZSHMQ_ROOT}/lib/topic_sub.sh"
  # shellcheck disable=SC1091
  . "${ZSHMQ_ROOT}/lib/bus.sh"
fi

zshmq_command_list() {
  if [ -n "${ZSHMQ_COMMAND_REGISTRY:-}" ]; then
    zshmq_registered_commands
    return
  fi

  for path in "${ZSHMQ_ROOT}/lib"/*.sh; do
    [ -f "$path" ] || continue
    cmd=${path##*/}
    cmd=${cmd%.sh}
    [ "$cmd" = "command_helpers" ] && continue
    [ "$cmd" = "logging" ] && continue
    printf '%s\n' "$cmd"
  done
}

zshmq_show_command_help() {
  cmd=$1
  zshmq_command_file "$cmd" >/dev/null 2>&1 || {
    printf 'Unknown command: %s\n' "$cmd"
    return 1
  }
  zshmq_print_command_help "$cmd"
}

zshmq_show_help() {
  printf '%s\n' 'Zero Shell Message Queue (zshmq)'
  printf '%s\n' ''
  printf '%s\n' 'Usage: zshmq <command> [options]'
  printf '%s\n' ''
  printf '%s\n' 'Commands:'
  for cmd in $(zshmq_command_list); do
    summary=$(zshmq_command_summary "$cmd")
    printf '  %s - %s\n' "$cmd" "$summary"
  done
  printf '\n'
  printf '%s\n' 'Each command supports -h/--help plus -d/--debug and -t/--trace for log verbosity.'
  printf '%s\n' 'Run `zshmq help <command>` or `zshmq <command> --help` for command-specific documentation.'
}

if [ $# -eq 0 ]; then
  zshmq_show_help
  exit 0
fi

command_name=$1
shift

case $command_name in
  -h|--help|help)
    if [ $# -eq 0 ]; then
      zshmq_show_help
    else
      help_target=$1
      zshmq_show_command_help "$help_target"
    fi
    exit 0
    ;;
  --version)
    printf '%s\n' "${ZSHMQ_VERSION:-0.0.0}"
    exit 0
    ;;
  ctx)
    ctx "$@"
    ;;
  topic)
    topic "$@"
    ;;
  bus)
    bus "$@"
    ;;
  *)
    printf 'zshmq: unknown command -- %s\n' "$command_name" >&2
    printf '%s\n' '' >&2
    zshmq_show_help >&2
    exit 1
    ;;
 esac
